"""Claude API processor for task/note extraction and creation."""

import json
import logging
from datetime import date
from pathlib import Path
from typing import Any

import anthropic

from d_brain.services.google_keep import GoogleKeepService
from d_brain.services.google_tasks import GoogleTasksService
from d_brain.services.session import SessionStore

logger = logging.getLogger(__name__)\n\n\nclass ClaudeAPIProcessor:\n    """Service for processing entries with Claude API and creating Google Tasks/Keep.\"\"\"\n\n    def __init__(self, vault_path: Path, google_credentials_path: str) -> None:\n        \"\"\"Initialize with vault path and Google credentials.\n\n        Args:\n            vault_path: Path to vault directory\n            google_credentials_path: Path to Google Service Account credentials JSON\n        \"\"\"\n        self.vault_path = Path(vault_path)\n        self.client = anthropic.Anthropic()\n        self.tasks_service = GoogleTasksService(google_credentials_path)\n        self.keep_service = GoogleKeepService(google_credentials_path)\n\n    def process_entry(self, text: str, user_id: int = 0) -> dict[str, Any]:\n        \"\"\"Process a single entry with Claude and create tasks/notes.\n\n        Args:\n            text: The entry text to process\n            user_id: Telegram user ID for context\n\n        Returns:\n            Processing report as dict\n        \"\"\"\n        today = date.today()\n\n        # Get session context for GTD processing\n        session_context = self._get_session_context(user_id)\n\n        prompt = f\"\"\"Ты - GTD-ассистент. Твоя задача обработать эту запись используя Getting Things Done методологию.\n\nКонтекст:\n- Дата: {today}\n- Язык: русский\n\n{session_context}\n\nЗапись для обработки:\n\"\"\"{text}\"\"\"\n\nВЫПОЛНИ:\n1. Проанализируй запись\n2. Классифицируй по GTD категориям:\n   - Задача (actionable item) - требует выполнения\n   - Справка (reference) - информация для сохранения\n   - Отложенное (waiting) - ожидание ответа от кого-то\n   - Когда-нибудь (someday/maybe) - интересно но не срочно\n3. Если это ЗАДАЧА:\n   - Создай её в Google Tasks\n   - Определи имеет ли она срок выполнения\n4. Если это СПРАВКА:\n   - Создай заметку в Google Keep\n5. Вернись результат в JSON:\n\n{{\n  \"type\": \"task\" | \"note\" | \"waiting\" | \"someday\",\n  \"title\": \"Заголовок\",\n  \"content\": \"Полное содержание\",\n  \"due_date\": \"YYYY-MM-DD\" или null,\n  \"created\": true/false,\n  \"status\": \"Статус выполнения\"\n}}\"\"\"\n\n        try:\n            message = self.client.messages.create(\n                model=\"claude-3-5-sonnet-20241022\",\n                max_tokens=1024,\n                messages=[\n                    {\n                        \"role\": \"user\",\n                        \"content\": prompt,\n                    }\n                ],\n            )\n\n            response_text = message.content[0].text\n\n            # Try to extract JSON from response\n            try:\n                # Find JSON in response (it might be wrapped in text)\n                json_start = response_text.find(\"{\")\n                json_end = response_text.rfind(\"}\") + 1\n                if json_start >= 0 and json_end > json_start:\n                    json_str = response_text[json_start:json_end]\n                    result = json.loads(json_str)\n                else:\n                    # Fallback: return as note\n                    result = {\n                        \"type\": \"note\",\n                        \"title\": text[:50],\n                        \"content\": text,\n                        \"created\": False,\n                        \"status\": \"Не удалось распарсить ответ Claude\",\n                    }\n            except json.JSONDecodeError:\n                logger.warning(\"Failed to parse Claude response as JSON\")\n                result = {\n                    \"type\": \"note\",\n                    \"title\": text[:50],\n                    \"content\": text,\n                    \"created\": False,\n                    \"status\": \"Parsing error\",\n                }\n\n            # Create task or note based on classification\n            if result[\"type\"] == \"task\":\n                try:\n                    task = self.tasks_service.create_task(\n                        title=result[\"title\"],\n                        notes=result[\"content\"],\n                        due_date=result.get(\"due_date\", \"\"),\n                    )\n                    result[\"created\"] = True\n                    result[\"status\"] = \"✓ Создана задача\"\n                    logger.info(\"Created task: %s\", task.get(\"id\"))\n                except Exception as e:\n                    logger.error(\"Failed to create task: %s\", e)\n                    result[\"created\"] = False\n                    result[\"status\"] = f\"Ошибка создания задачи: {e}\"\n\n            elif result[\"type\"] == \"note\":\n                try:\n                    note = self.keep_service.create_note(\n                        title=result[\"title\"],\n                        content=result[\"content\"],\n                    )\n                    result[\"created\"] = True\n                    result[\"status\"] = \"✓ Создана заметка\"\n                    logger.info(\"Created note: %s\", note.get(\"name\"))\n                except Exception as e:\n                    logger.error(\"Failed to create note: %s\", e)\n                    result[\"created\"] = False\n                    result[\"status\"] = f\"Ошибка создания заметки: {e}\"\n\n            return result\n\n        except anthropic.APIError as e:\n            logger.error(\"Claude API error: %s\", e)\n            return {\n                \"type\": \"error\",\n                \"status\": f\"API error: {e}\",\n                \"created\": False,\n            }\n        except Exception as e:\n            logger.exception(\"Unexpected error during processing\")\n            return {\n                \"type\": \"error\",\n                \"status\": f\"Error: {e}\",\n                \"created\": False,\n            }\n\n    def _get_session_context(self, user_id: int) -> str:\n        \"\"\"Get today's session context for Claude.\n\n        Args:\n            user_id: Telegram user ID\n\n        Returns:\n            Recent session entries formatted for inclusion in prompt.\n        \"\"\"\n        if user_id == 0:\n            return \"\"\n\n        try:\n            session = SessionStore(self.vault_path)\n            today_entries = session.get_today(user_id)\n            if not today_entries:\n                return \"\"\n\n            lines = [\"=== КОНТЕКСТ СЕГОДНЯ ===\"]\n            for entry in today_entries[-5:]:\n                ts = entry.get(\"ts\", \"\")[11:16]  # HH:MM from ISO\n                entry_type = entry.get(\"type\", \"unknown\")\n                text = entry.get(\"text\", \"\")[:60]\n                if text:\n                    lines.append(f\"{ts} [{entry_type}] {text}...\")\n            lines.append(\"=== КОНЕЦ КОНТЕКСТА ===\\n\")\n            return \"\\n\".join(lines)\n        except Exception as e:\n            logger.warning(\"Failed to get session context: %s\", e)\n            return \"\"\n